# 原型模式

### 基本介绍

1. 原型模式是指: 用原型实例指定创建对象的种类, 并且通过拷贝这些原型, 创建新的对象.
2. 原型模式是一种创建型模式, 允许一个对象创建另外一个可定制的对象, 无需知道如何创建的细节.
3. 工作原理: 通过讲一个原型对象传递个那个要发动创建的对象, 这个要发动创建的对象通过请求原型对象拷贝他们自己来实施创建. 即**对象.clone()**




### 框架中的原型模式

* Spring 中原型 bean 的创建, 就是原型模式的应用.




### 浅拷贝和深拷贝

#### 浅拷贝_基本介绍

* 对于数类型是基本数据类型的成员变量, 浅拷贝会直接进行值传递, 也就是将该属性值复制一份给新的对象.
* 对于数据类型是引用类型的成员变量, 比如说成员变量是某个数组、某个类的对象等, 那么浅拷贝会进行引用传递, 也就是将改成员变量的引用值(内存地址)复制一份给新的对象. 因为实际上两个对象的该成员都指向同一个实例. 在这种情况下, 在一个对象中修改成员变量会影响到另一个对象的该成员变量值.
  * 实现方式
    1. 使用默认的 clone() 方法实现



#### 深拷贝_基本介绍

* 复制对象的所有基本数据类型的成员变量值
* 为所有引用数据类型的成员变量申请存储空间, 并复制每个引用数据类型成员变量所引用的对象, 直到该对象可达的所有对象. 也就是说, 对象进行深拷贝要对整个对象进行拷贝.
  * 实现方式
    1. 重写 clone() 方法来实现深拷贝
    2. 通过对象序列化实现深拷贝



### 注意事项和细节

1. 创建新的对象比较复杂时, 可以利用原型模式简化对象的创建过程, 同时也能够提高效率.
2. 不用重新初始化对象, 而是动态地获得对象运行时的状态.
3. 如果原始对象发生变化(增加或者减少属性), 其克隆的对象也会发生相应的变化,而不用修改代码.
4. 在实现深拷贝的时候可能需要比较复杂的代码.
5. **缺点** 需要为每一个类配备一个克隆方法, 这对全新的类来说不是很难, 但对已有的类进行改造时, 需要修改其源代码, 违背了OCP原则. 这一点需要注意.